= Interscript Script Conversion Language (LCS)

== Purpose

DSL for defining a script conversion process.

WARNING: This is in experimentation stage. Use with caution.

== Class Structure

Builder::
the DSL

Atom::
a thing generated by the DSL

Item::
an item interface

Alias < Item::
generated in the DSL for example like: alias :alpha, any('a' .. 'z'), referenced like: alias(:alpha)

Character < Item::
a basic character atom

Group < Item::
items can be concatenated, eg. any('a' .. 'z') + alias(:jamo) + alias(:jamo_vowel) - group is a result of concatenation (or alternation maybe?)

Rule::
a rule interface, responds to #reverse

Parallel < Rule::
a grouping of rules to be executed in a parallel manner (map/dictionary)

Sequential < Rule::
a grouping of rules to be executed sequentially (rules/postrules) - also the root Atom

Replacement < Rule - a basic replacement rule (eg. sub any("あ", "ア"), "a", not_after: alias(:alpha) )

External < Rule::
for integration of external processes

Compiler::
takes the tree of Atoms generated by the DSL and does something with it

Compiler::Ruby::
compiles the syntax tree into a Ruby file

Compiler::JS::
ditto but in JS

Compiler::C::
ditto in C

Compiler::Interscript1_YAML::
generates an Interscript1 YAML map file (newer features may not be supported in Interscript 1 YAML)

Compiler::UnicodeXML::
generates an XML compatible with some Unicode standard (if the CLDR format is any useful)

Interpreter::
a special case of a compiler maybe that executes the Item tree

Map::
this would be generated by the Compiler

Runtime::
a set of helper functions for a file generated by a compiler, can be reimplemented in C, JS, ...

Functionality will be limited in non-native implementations, such as Compiler::Interscript1_YAML, to those that are supported by that compiler.

Maybe Map and Builder would be somehow integrated. It is yet unclear.

Sample Ruby code:
[source,ruby]
----
class UNKorKoreLatn2015 < Map
  # loads aliases related to Korean language
  include Korean
  # loads function that allows calling `kore_to_hang` to convert Korean to Jamo
  include Korean::KoreHang
  # loads function that allows calling `hang_to_kore` to convert Jamo to Korean
  include Korean::HangKore
----

All those would be modules.

* If performance is important then the C module could be reused in Ruby and JS (via WASM).
* `Test` would be an Item, made by the DSL with test "あ", "a".
* Metadata would be an Item.

Helper functions could be done, like:

[source]
----
any_char("aoeui") # will mean `any("a", "o", "e", "i", "u")`
----

* `rule "a", "b"` could be reversed into `rule "b", "a"`
* `rule "a", "b", before: "c"` could be reversed into `rule "b", "a", before: "c"`

[source,ruby]
----
sequential do
  rule "a", "b"
  rule "c", "d"
end
----

would be reversed into

[source,ruby]
----
sequential do
  rule "d", "c"
  rule "b", "a"
end
----

Actually there could be Parsers written which would take some existing maps and output DSL Ruby file or a list of Atoms. a list of Atoms could be converted to a DSL file possibly.

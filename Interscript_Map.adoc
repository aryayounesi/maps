= Interscript Map format syntax

This document describes the DSL-based files with an extension `.iml` or `.imp`.

An `.imp` file is a file containing a standalone transliteration map. For
instance, a map that can transliterate a Korean file to a Latin file.

An `.iml` file is a file that contains a library of aliases and stages to be
used by the `.imp` maps. It follows the same format, but does not require the
metadata and tests parts to exist and doesn't allow the `:main` stage to exist.
This document describes the map version of the format if it isn't noted
otherwise.

Those files are in essence Ruby programs using a DSL described below. A
non-programmer should not be necessarily concerned about this, but treat this
format as if it were a YAML file, with certain restrictions regarding the
syntax, a programmer should note that those programs are not executed directly
to transliterate a string, but they are meant to be compiled to other languages.
Therefore an assumption that full programming power is available from this part
is wrong. Such an assumption, while wrong, does not mean that the format can't
be extended to allow for such usecases.

== Ruby syntax

This document does not assume a person has a knowledge of any programming
language. It assumes that a person has some knowledge about some basic
structured data formats, like YAML or XML.

A `\#` character is a comment character. This means, that the part that follows
a `#` character till the end of the line is ignored by Interscript, but exist to
communicate to a human reader the intention behind the content. In this document
it is most often a hint to a person reading this document.

A String is a part of the document of a form either: `"content"` or `'content'`.
It denotes a group of characters to be used. It can be joined together using a
`+` character like so: `"a" + "b"` which is equal to as if someone wrote just
`"ab"`.

There is another way to convey a string, a HEREDOC notation which may be used in
some maps, especially for multiline descriptions. It is a form of this kind:

[source,ruby]
----
<<~END
  Here comes a string
  spanning multiple lines
END
----

The reader shouldn't be concerned about this too much, but know that all those
forms are interchangeable. The choice of the form depends on a context. For
example to express a character `"` one would want to write `'"'` to be
unambiguous, as `'''` is invalid Ruby code.

Except for the strings of the form `'content'`, all those forms can contain
escape forms like `\u0410`, which means "An Unicode character 0410". The usage
of those forms is discouraged in new maps, but possible.

An array (or a list) is a part of the document of a form `["a", "b", "c"]`. It
means a sequential group of Strings, or other types.

This section does not explain the Ruby syntax over what is needed to write or
understand an Interscript map.

== Document

The root part of the `.iml` file is called a document. A map has a format as
follows:

[source,ruby]
----
metadata do
  # Metadata part comes here
end

tests do
  # Tests part comes here
end

# A dependency directive may happen zero or more times. It will be described in
# a subsection.
dependency "other-map-or-library", as: :shortname

# This part is optional
aliases do
  # Aliases part comes here
end

stage do
  # A stage description comes here
end

# There may be more than 1 stage, the other stages need to have a name. The
# default stage name is :main. A name can't happen more than once in a document.

stage :named_stage do
  # A stage description comes here
end
----

=== Dependency

Dependency is an instruction to be issued only in the document context. It means
that we want to import some aliases or stages from another map or a library.

[source,ruby]
----
dependency "other-map-or-library", as: :shortname
----

This instruction will allow us to reference aliases and stages from other
libraries in this form: `map[:shortname].stage[:stagename]` for stages and
`map[:shortname][:aliasname]` for aliases.

There is a second syntax, mostly useful for loading libraries that will import
the stages and aliases to a global context resulting in possibly more human
readable maps:

[source,ruby]
----
dependency "other-map-or-library", as: :shortname, import: true
----

This form allows to reference other stages and aliases in the following form:
`stage[:stagename]`, `aliasname`

It is not possible to load maps using this form, only libraries, because we
can't override the :main stage.

The standard library is implicitly imported this way. There's no way or need to
import it explicitly.

==== Standard library

All maps depend on a standard library implicitly. This standard library defines
a few useful aliases that may or may not be expressed otherwise.

Below is a table that describes the aliases defined by the standard library:

|===
| `none`           | An empty string
| `space`          | A space character
| `whitespace`     | Any whitespace ascii character (space, tab, line-delimiter, ...)
| `boundary`       | A word boundary (see below for what institutes a word character)
| `word`           | An ascii word character (a-z, A-Z, 0-9, _)
| `not_word`       | Negation of the above
| `alpha`          | Any ascii alphabetic character (a-z, A-Z)
| `not_alpha`      | Negation of the above
| `digit`          | Any ascii digit
| `not_digit`      | Negation of the above
| `line_start`     | Beginning of a line
| `line_end`       | Ending of a line
| `string_start`   | Beginning of a string
| `string_end`     | Ending of a string
|===

Any standard library (or otherwise) aliases can be joined with anything else
using a + command, for example: `line_start + "rest"`.

== Metadata part

The metadata part describes our map.

[source,ruby]
----
metadata do
  # ID of the authority that provided the transliteration rules we are about to implement
  authority_id "iso"
  # ID of the rules, most often the year they were defined
  id "1996-method1"
  # The language code of the map
  language "iso-639-2:kor"
  # The source script of our map, in our example Hang for Hangul
  source_script "Hang"
  # The destination script of our map
  destination_script "Latn"
  # The longer name of our map
  name "ISO/TR 11941:1996 Information and documentation — Transliteration of Korean script into Latin characters"
  # The URL where it was published
  url "https://www.iso.org/standard/20564.html"
  # The creation date of our map
  creation_date "1996"
  # The adoption date of our map, or empty if not adopted
  adoption_date ""
  # The description of our map
  description "Establishes a system for the transliteration of the characters of Korean script into Latin characters. "+
              "Intended to provide a means for international communication of written documents."
  # The notes that describe some parts of our map that we are about to implement
  notes [
    "A word-initial hard sign 'ъ' is not represented, but instead is left out of the transliteration.",
    "The romanization follows the dialect spoken in Chechnya rather than other local pronunciations.",
  ]
end
----

== Tests part

The tests part describes a group of the tests to be executed by the automated
system to verify that the map is defined properly. An example tests part looks
like this:

[source,ruby]
----
tests do
  test "애기", "aeki"
  test "방", "pang"
end
----

This means, that we want to test our map to transliterate a string "애기" to
"aeki" and "방" to "pang".

== Aliases part

An aliases part describes a group of aliases to be used by the stages to
simplify the code of our map.

Let's suppose that our map refers to "Double consonant jamo" and "Aspirated
consonant jamo" quite extensively. We can alias those

[source,ruby]
----
aliases do
  def_alias :double_cons_jamo, any("ᄁᄄᄈᄍᄊ")
  def_alias :aspirated_cons_jamo, any("ᄏᄐᄑᄎ")
end
----

And later in the stage part refer to them by just `double_cons_jamo`, not
needing to repeat ourselves.

== Stage part

A stage part describes a stage, a sequential group of steps to transliterate
a string from a source script code to a destination script code. An example
stage looks like the following:

[source,ruby]
----
stage do
  run map[:hangjamo].stage[:main]
  sub any("ᄀᆨ"), "k"
  sub any("ᄏᆿ"), "kh"
  parallel do
    sub "ᅡ", "a"
    sub "ᅥ", "eo"
  end
end
----

A stage can be named, as described in the Document section. The default name
of a stage is `:main`.

=== `sub` call

A `sub` call does a substitution of an item (string, character, alias) with
another item.

[source,ruby]
----
stage do
  sub "source", "destination"
end
----

This call allows for some named parameters:

[cols="2"]
|===
| `before:`
| Execute this substitution only if the "source" is preceded by what is given
  as a parameter, but won't replace it, it will only replace the "source".

| `after:`
| Same, but this parameter denotes what is used after.

| `not_before:`, `not_after:`
| Negation of `before:` and `after:`. The substitution will only happen if a
  parameter is NOT present before or after the "source".
|===

For example:

[source,ruby]
----
stage do
  sub boundary + "Е", "Ye", not_before: boundary + "’"
  sub boundary + "е", "ye", not_before: boundary + "’"

  sub none, "'", not_before: hangul, after: aspirated_cons
end
----

=== `parallel` block

A parallel block can be defined as a subsection of a `stage` part. It indicates
that the steps inside need to be executed in parallel. At the current time, only
`sub` calls can be executed in parallel (with a limited functionality). It also
means, that those steps will try to find the longest substrings first.

[source,ruby]
----
stage do
  parallel do
    sub "А", 'A'
    sub "Б", 'B'
    sub "В", 'V'
    sub "Г", 'G'
  end
end
----

=== `run` call

The run call runs a stage defined inside the document, or another map or
library. If this map isn't local, a map or library dependency needs to be
declared using the `dependency` call.

For example:

[source,ruby]
----
stage do
  # If dependency declared with import: true
  run map[:hangjamo].stage[:main]
  # If dependency declated without import: true, or we reference a local stage
  run stage[:remove_spaces]
end
----

=== `external` call

The external call is not defined yet. It exists for compatibility with older
maps.

== Items

Interscript doesn't work purely on Strings, even though Strings are mostly
referenced to by this document. The items can be used in the `alias` and `stage`
context.

=== String item

The most basic kind of item. For example `"Г"` means "match Г" or "replace
with Г" depending on usage context. Some contexts will only accept strings, or
aliases to strings.

=== `+` method

Items can be concatenated (added together) to denote a complex item. For instance:
`any("ab") + "e"` means "either ae or be" and is equivalent to `any(["ae", "be"])`.

=== `any` item

Any denotes some alternative variations of a string. It has 3 forms of call:

* `any("abcde")` - any character: a, b, c, d or e
* `any(["one", "two"])` - any string: one or two
* `any("a".."z")` - any character from a to z

Any can be also used with other kinds of items than String, for instance:

[source,ruby]
----
stage do
  sub any([line_start + "a", "a" + line_end]), none
end
----

=== `alias` item

An alias item references an alias. For example `map[:other_map][:alias_from_other_map]`
or simply `a_local_alias_or_an_alias_from_imported_library`.

== Ending notes

This document described everything Interscript currently supports, but it is
strongly advised to read the existing maps to get a grasp of how those
functionalities can be used best.
